#if 0
	shc Version 3.8.7, Generic Script Compiler
	Copyright (c) 1994-2009 Francisco Rosales <frosal@fi.upm.es>

	shc -v -r -T -f mountCheckerInitiator.sh 
#endif

static  char data [] = 
#define      opts_z	1
#define      opts	((&data[0]))
	"\237"
#define      date_z	1
#define      date	((&data[1]))
	"\146"
#define      msg2_z	19
#define      msg2	((&data[2]))
	"\050\364\104\170\120\116\160\344\274\300\106\027\130\031\060\301"
	"\327\323\142"
#define      inlo_z	3
#define      inlo	((&data[21]))
	"\200\155\101"
#define      rlax_z	1
#define      rlax	((&data[24]))
	"\133"
#define      xecc_z	15
#define      xecc	((&data[25]))
	"\342\345\027\334\341\100\276\000\101\243\210\072\052\233\216\161"
	"\263\235"
#define      tst1_z	22
#define      tst1	((&data[46]))
	"\062\123\244\324\353\302\043\226\133\032\042\326\221\131\101\020"
	"\032\350\072\264\355\261\350\302\073\043\144"
#define      tst2_z	19
#define      tst2	((&data[70]))
	"\365\165\145\036\340\324\020\205\260\057\363\127\315\175\043\341"
	"\017\367\263"
#define      text_z	552
#define      text	((&data[184]))
	"\370\076\363\013\113\100\346\160\371\161\131\127\256\034\311\142"
	"\271\106\373\045\170\116\312\233\263\252\236\343\134\116\073\125"
	"\214\056\140\330\157\107\111\151\270\242\300\147\276\212\311\170"
	"\320\305\235\111\024\150\345\307\022\203\253\157\322\346\304\136"
	"\024\045\066\204\154\177\355\044\042\256\213\340\070\125\130\011"
	"\033\366\123\057\136\070\366\161\274\241\341\216\207\245\355\205"
	"\320\211\342\061\321\040\104\216\301\073\165\074\345\274\166\176"
	"\013\137\031\126\213\247\147\235\123\202\261\307\011\072\214\141"
	"\102\027\345\133\315\325\260\021\343\217\174\104\175\375\233\304"
	"\370\271\026\322\234\076\052\075\345\157\112\070\101\354\204\013"
	"\343\275\007\245\305\055\161\175\313\252\065\044\323\206\060\045"
	"\321\126\300\301\356\041\136\271\373\313\153\075\357\062\343\056"
	"\202\043\140\166\017\240\062\365\221\277\365\126\330\045\143\360"
	"\322\302\170\232\102\356\274\137\332\324\372\151\150\103\177\271"
	"\111\235\313\377\111\306\344\035\301\367\075\201\012\040\163\142"
	"\376\332\144\160\001\153\212\374\211\020\057\074\345\143\127\004"
	"\172\244\121\210\271\145\176\247\161\030\006\155\354\012\314\071"
	"\040\160\025\252\364\220\370\374\330\342\030\204\230\125\155\005"
	"\236\313\304\153\350\123\332\155\316\147\275\071\003\372\313\203"
	"\040\330\265\174\233\020\315\030\366\310\177\020\347\310\013\370"
	"\236\374\261\255\322\111\343\170\167\234\336\306\321\177\214\023"
	"\036\211\102\065\066\113\174\356\251\013\011\032\345\252\200\063"
	"\334\101\156\225\315\207\151\245\120\172\123\367\114\265\230\213"
	"\251\212\235\130\336\173\356\360\313\247\055\332\012\202\011\273"
	"\100\201\170\015\370\041\006\352\165\120\023\003\036\117\056\051"
	"\061\031\025\023\062\115\341\373\162\322\262\337\165\155\124\365"
	"\124\016\144\055\267\071\010\142\007\177\276\237\236\061\241\210"
	"\021\166\032\125\075\371\206\020\276\003\005\172\336\227\262\353"
	"\202\250\236\265\264\253\103\371\150\166\115\240\336\256\254\153"
	"\317\051\136\016\001\137\163\007\144\353\254\320\341\357\045\326"
	"\363\161\261\044\024\015\207\232\365\212\102\147\271\272\373\373"
	"\176\242\013\143\020\313\267\371\155\005\027\011\300\036\241\241"
	"\113\013\277\123\007\156\157\066\045\261\002\121\264\375\011\205"
	"\125\140\375\304\130\231\013\237\016\232\306\345\356\314\031\070"
	"\225\373\273\337\034\324\355\226\326\305\270\256\165\003\226\212"
	"\165\060\224\344\016\103\273\374\050\171\125\102\032\136\123\236"
	"\162\257\330\374\315\267\273\214\013\344\133\055\026\103\147\143"
	"\227\366\047\145\345\053\223\373\142\201\200\161\255\053\007\107"
	"\075\132\306\367\165\232\244\317\153\132\325\107\277\043\200\124"
	"\356\346\131\341\350\046\143\051\314\147\132\313\170\364\156\261"
	"\172\010\274\016\243\033\066\234\312\044\040\067\244\016\133\306"
	"\274\347\247\364\075\000\376\130\366\121\207\125\212\175\307\106"
	"\037\250\325\246\115\302\103\030\346\144\117\213\162\253\121\056"
	"\223\370\043\320\370\042"
#define      shll_z	10
#define      shll	((&data[785]))
	"\261\104\366\117\347\143\277\370\073\033\071\212\375"
#define      lsto_z	1
#define      lsto	((&data[796]))
	"\345"
#define      chk1_z	22
#define      chk1	((&data[801]))
	"\364\002\333\070\060\337\037\015\334\275\242\243\315\242\017\315"
	"\364\202\370\177\057\253\323\232\335\062"
#define      msg1_z	42
#define      msg1	((&data[831]))
	"\152\115\017\026\237\075\251\227\031\334\037\365\272\121\337\201"
	"\011\015\152\366\322\116\056\371\356\164\015\131\353\215\355\075"
	"\071\335\371\062\373\012\006\212\117\064\340\245\326\202\101\222"
	"\332\026\141\172\220\203\244\177"
#define      chk2_z	19
#define      chk2	((&data[880]))
	"\364\205\303\333\261\250\264\071\140\130\006\056\337\025\020\123"
	"\035\120\347\040\204\320\070"
#define      pswd_z	256
#define      pswd	((&data[935]))
	"\307\207\055\377\242\360\234\015\075\253\043\334\351\315\164\113"
	"\110\004\317\354\204\306\101\110\273\306\030\364\230\236\106\140"
	"\045\051\315\336\101\332\337\157\310\217\150\124\131\346\237\033"
	"\216\022\256\363\072\364\347\205\217\365\033\250\357\100\251\217"
	"\151\167\156\252\122\116\031\032\335\202\157\066\150\016\121\366"
	"\041\000\352\134\365\322\342\204\310\376\055\267\076\327\107\247"
	"\116\266\122\241\004\154\273\341\356\053\030\127\072\152\116\133"
	"\152\071\270\140\013\232\345\323\230\022\213\327\351\322\176\070"
	"\210\320\332\215\074\226\156\053\301\207\202\373\361\320\127\134"
	"\011\020\275\025\253\242\351\104\264\164\033\236\107\232\327\320"
	"\153\261\135\250\107\314\323\010\123\125\004\105\046\134\241\060"
	"\154\136\106\027\000\057\134\265\244\167\123\353\021\052\273\174"
	"\334\031\045\043\345\370\054\070\116\061\175\165\215\037\245\371"
	"\176\353\021\177\033\155\064\277\345\210\253\367\263\147\164\217"
	"\200\231\263\145\222\340\236\340\021\033\126\236\073\373\230\272"
	"\347\252\071\003\030\156\303\376\367\156\365\252\325\151\072\126"
	"\003\356\273\225\316\131\165\340\165\313\177\261\307\030\153\257"
	"\302\245\263\333\023\166\331\012\344\316\265\272\070\360\020\073"
	"\337\164\140\310\144\374\325\242\250\371\177\222\307\363\336\017"
	"\370\255\373\174\164"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask  = (unsigned long)&chkenv;
	mask ^= (unsigned long)getpid() * ~mask;
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;

	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	ret = chkenv(argc);
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		if (text_z < hide_z) {
			/* Prepend spaces til a hide_z script size. */
			scrpt = malloc(hide_z);
			if (!scrpt)
				return 0;
			memset(scrpt, (int) ' ', hide_z);
			memcpy(&scrpt[hide_z - text_z], text, text_z);
		} else {
			scrpt = text;	/* Script text */
		}
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, argv[0]);
		} else {
			scrpt = argv[0];
		}
	}
	j = 0;
	varg[j++] = argv[0];		/* My own name at execution */
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
